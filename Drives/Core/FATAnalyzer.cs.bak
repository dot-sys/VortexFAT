using Drives.Models;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Principal;
using System.Text;

// Core file system analysis and recovery operations.
namespace Drives.Core
{
    // Analyzes and recovers files from FAT file systems.
    public class FATAnalyzer
    {
        // Minimum valid cluster number for FAT systems.
        private const uint FAT32_MIN_CLUSTER = 2;
        // End of chain marker for FAT32.
        private const uint FAT32_EOC_MARKER = 0x0FFFFFF8;
        // End of chain marker for FAT16.
        private const uint FAT16_EOC_MARKER = 0xFFF8;
        // End of chain marker for exFAT.
        private const uint EXFAT_EOC_MARKER = 0xFFFFFFF7;
        // Size of directory entry in bytes.
        private const int DIRECTORY_ENTRY_SIZE = 32;
        // Marker for deleted file entries.
        private const byte DELETED_MARKER = 0xE5;
        // Marker indicating end of directory entries.
        private const byte DIRECTORY_END_MARKER = 0x00;
        // Attribute value for long file name entries.
        private const byte LFN_ATTRIBUTE = 0x0F;
        // Attribute flag for volume label entries.
        private const byte VOLUME_LABEL_ATTRIBUTE = 0x08;
        // Attribute flag for directory entries.
        private const byte DIRECTORY_ATTRIBUTE = 0x10;
        // Default cluster size fallback value.
        private const long DEFAULT_CLUSTER_SIZE = 4096;

        // Drive letter being analyzed.
        private readonly string _driveLetter;
        // Drive information and metadata.
        private readonly Models.DriveInfo _driveInfo;
        // Indicates if file system is exFAT.
        private readonly bool _isExFAT;
        // Indicates if file system is FAT16.
        private readonly bool _isFAT16;

        // Initializes analyzer for specified drive.
        public FATAnalyzer(string driveLetter)
        {
            _driveLetter = driveLetter.TrimEnd('\\');
            _driveInfo = DriveDetector.GetAllDrives()
                .FirstOrDefault(d => d.DriveLetter.Equals(_driveLetter, StringComparison.OrdinalIgnoreCase));

            if (_driveInfo == null || !_driveInfo.IsSupported)
            {
                throw new ArgumentException($"Drive {driveLetter} is not a supported FAT file system.");
            }

            _isExFAT = _driveInfo.FileSystem.Equals("exFAT", StringComparison.OrdinalIgnoreCase);
            _isFAT16 = _driveInfo.FileSystem.Equals("FAT", StringComparison.OrdinalIgnoreCase);
        }

        // Retrieves list of existing files on drive.
        public List<FileEntry> GetExistingFiles()
        {
            var files = new List<FileEntry>();

            try
            {
                var rootPath = _driveLetter + "\\";
                EnumerateFilesRecursive(rootPath, files);
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error analyzing drive {_driveLetter}: {ex.Message}");
            }

            return files;
        }

        // Recursively enumerates files and directories from path.
        private void EnumerateFilesRecursive(string path, List<FileEntry> files)
        {
            try
            {
                var dirInfo = new DirectoryInfo(path);

                var directories = dirInfo.GetDirectories();
                foreach (var directory in directories)
                {
                    try
                    {
                        var dirEntry = new FileEntry
                        {
                            FileName = directory.Name,
                            FullPath = directory.FullName,
                            FileSize = 0,
                            FileSizeFormatted = "<DIR>",
                            Status = "Present",
                            CreationTime = directory.CreationTime,
                            ModifiedTime = directory.LastWriteTime,
                            AccessedTime = directory.LastAccessTime,
                            Attributes = directory.Attributes.ToString(),
                            IsDeleted = false,
                            IsDirectory = true,
                            SlackSpace = 0,
                            Signature = string.Empty
                        };

                        files.Add(dirEntry);
                    }
                    catch (Exception ex)
                    {
                        System.Diagnostics.Debug.WriteLine($"Error accessing directory info {directory.FullName}: {ex.Message}");
                    }
                }

                var fileInfos = dirInfo.GetFiles();

                foreach (var fileInfo in fileInfos)
                {
                    try
                    {
                        var entry = new FileEntry
                        {
                            FileName = fileInfo.Name,
                            FullPath = fileInfo.FullName,
                            FileSize = fileInfo.Length,
                            FileSizeFormatted = FormatBytes(fileInfo.Length),
                            Status = "Present",
                            CreationTime = fileInfo.CreationTime,
                            ModifiedTime = fileInfo.LastWriteTime,
                            AccessedTime = fileInfo.LastAccessTime,
                            Attributes = fileInfo.Attributes.ToString(),
                            IsDeleted = false,
                            IsDirectory = false,
                            Signature = SignatureVerifier.CheckSignature(fileInfo.FullName)
                        };

                        files.Add(entry);
                    }
                    catch (Exception ex)
                    {
                        System.Diagnostics.Debug.WriteLine($"Error accessing file {fileInfo.FullName}: {ex.Message}");
                    }
                }

                foreach (var directory in directories)
                {
                    try
                    {
                        EnumerateFilesRecursive(directory.FullName, files);
                    }
                    catch (Exception ex)
                    {
                        System.Diagnostics.Debug.WriteLine($"Error accessing directory {directory.FullName}: {ex.Message}");
                    }
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error enumerating path {path}: {ex.Message}");
            }
        }

        // Scans disk for deleted files using FAT.
        public List<FileEntry> GetDeletedFiles()
        {
            var deletedFiles = new List<FileEntry>();

            try
            {
                if (!IsAdministrator())
                {
                    throw new UnauthorizedAccessException("Administrator privileges required for low-level disk access.");
                }

                System.Diagnostics.Debug.WriteLine($"Starting deleted file scan on {_driveLetter} (File System: {_driveInfo.FileSystem})");

                string drivePath = $"\\\\.\\{_driveLetter.TrimEnd('\\')}" ;

                using (var driveStream = new FileStream(drivePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                {
                    if (_isExFAT)
                    {
                        var exFatBootSector = ReadExFATBootSector(driveStream);
                        if (exFatBootSector == null)
                        {
                            System.Diagnostics.Debug.WriteLine("Failed to read exFAT boot sector");
                            return deletedFiles;
                        }

                        System.Diagnostics.Debug.WriteLine($"exFAT Boot Sector Info:");
                        System.Diagnostics.Debug.WriteLine($"  Bytes per sector: {exFatBootSector.BytesPerSector}");
                        System.Diagnostics.Debug.WriteLine($"  Sectors per cluster: {exFatBootSector.SectorsPerCluster}");
                        System.Diagnostics.Debug.WriteLine($"  Cluster heap offset: {exFatBootSector.ClusterHeapOffset}");
                        System.Diagnostics.Debug.WriteLine($"  Root directory cluster: {exFatBootSector.RootDirectoryCluster}");

                        string rootPath = _driveLetter.TrimEnd('\\') + "\\";
                        ScanExFATDirectoryCluster(driveStream, exFatBootSector, exFatBootSector.RootDirectoryCluster, rootPath, deletedFiles, new HashSet<uint>());
                    }
                    else if (_isFAT16)
                    {
                        var bootSector = ReadFAT16BootSector(driveStream);
                        if (bootSector == null)
                        {
                            System.Diagnostics.Debug.WriteLine("Failed to read FAT16 boot sector");
                            return deletedFiles;
                        }

                        System.Diagnostics.Debug.WriteLine($"FAT16 Boot Sector Info:");
                        System.Diagnostics.Debug.WriteLine($"  Bytes per sector: {bootSector.BytesPerSector}");
                        System.Diagnostics.Debug.WriteLine($"  Sectors per cluster: {bootSector.SectorsPerCluster}");
                        System.Diagnostics.Debug.WriteLine($"  Reserved sectors: {bootSector.ReservedSectors}");
                        System.Diagnostics.Debug.WriteLine($"  FAT count: {bootSector.NumberOfFATs}");
                        System.Diagnostics.Debug.WriteLine($"  Sectors per FAT: {bootSector.SectorsPerFAT}");
                        System.Diagnostics.Debug.WriteLine($"  Root entry count: {bootSector.RootEntryCount}");

                        string rootPath = _driveLetter.TrimEnd('\\') + "\\";
                        ScanFAT16RootDirectory(driveStream, bootSector, rootPath, deletedFiles);
                    }
                    else
                    {
                        var bootSector = ReadBootSector(driveStream);
                        if (bootSector == null)
                        {
                            System.Diagnostics.Debug.WriteLine("Failed to read boot sector");
                            return deletedFiles;
                        }

                        System.Diagnostics.Debug.WriteLine($"Boot Sector Info:");
                        System.Diagnostics.Debug.WriteLine($"  Bytes per sector: {bootSector.BytesPerSector}");
                        System.Diagnostics.Debug.WriteLine($"  Sectors per cluster: {bootSector.SectorsPerCluster}");
                        System.Diagnostics.Debug.WriteLine($"  Reserved sectors: {bootSector.ReservedSectors}");
                        System.Diagnostics.Debug.WriteLine($"  FAT count: {bootSector.NumberOfFATs}");
                        System.Diagnostics.Debug.WriteLine($"  Sectors per FAT: {bootSector.SectorsPerFAT}");
                        System.Diagnostics.Debug.WriteLine($"  Root cluster: {bootSector.RootCluster}");

                        string rootPath = _driveLetter.TrimEnd('\\') + "\\";
                        ScanDirectoryCluster(driveStream, bootSector, bootSector.RootCluster, rootPath, deletedFiles, new HashSet<uint>());
                    }
                }

                System.Diagnostics.Debug.WriteLine($"Deleted file scan complete. Found {deletedFiles.Count} deleted items.");
            }
            catch (UnauthorizedAccessException)
            {
                throw;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error scanning for deleted files: {ex.Message}");
                System.Diagnostics.Debug.WriteLine($"Stack: {ex.StackTrace}");
            }

                        return deletedFiles;
                    }

                    private string BuildSubdirectoryPath(string parentPath, string subdirName)
                {
                        return parentPath.EndsWith("\\") ? parentPath + subdirName : parentPath + "\\" + subdirName;
                    }

                    private string BuildFullFilePath(string dirPath, string fileName)
                {
                    string basePath = dirPath.EndsWith("\\") ? dirPath : dirPath + "\\";
                        return basePath + fileName;
                    }

                    private bool IsValidFAT32Cluster(uint cluster)
                {
                        return cluster >= FAT32_MIN_CLUSTER && cluster < FAT32_EOC_MARKER;
                    }

                    private bool IsValidFAT16Cluster(uint cluster)
                {
                        return cluster >= FAT32_MIN_CLUSTER && cluster < FAT16_EOC_MARKER;
                    }

                    private bool IsValidExFATCluster(uint cluster)
                {
                        return cluster >= FAT32_MIN_CLUSTER && cluster < EXFAT_EOC_MARKER;
                    }

                    private FAT32BootSector ReadBootSector(Stream diskStream)
        {
            try
            {
                byte[] sector = new byte[512];
                diskStream.Position = 0;
                diskStream.Read(sector, 0, 512);

                var bootSector = new FAT32BootSector
                {
                    BytesPerSector = BitConverter.ToUInt16(sector, 11),
                    SectorsPerCluster = sector[13],
                    ReservedSectors = BitConverter.ToUInt16(sector, 14),
                    NumberOfFATs = sector[16],
                    SectorsPerFAT = BitConverter.ToUInt32(sector, 36),
                    RootCluster = BitConverter.ToUInt32(sector, 44)
                };

                return bootSector;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error reading boot sector: {ex.Message}");
                return null;
                    }
                }

                private ExFATBootSector ReadExFATBootSector(Stream diskStream)
        {
            try
            {
                byte[] sector = new byte[512];
                diskStream.Position = 0;
                diskStream.Read(sector, 0, 512);

                string signature = Encoding.ASCII.GetString(sector, 3, 8);
                if (signature != "EXFAT   ")
                {
                    System.Diagnostics.Debug.WriteLine($"Invalid exFAT signature: {signature}");
                    return null;
                }

                var bootSector = new ExFATBootSector
                {
                    BytesPerSectorShift = sector[108],
                    SectorsPerClusterShift = sector[109],
                    NumberOfFATs = sector[110],
                    PartitionOffset = BitConverter.ToUInt64(sector, 64),
                    VolumeLength = BitConverter.ToUInt64(sector, 72),
                    FATOffset = BitConverter.ToUInt32(sector, 80),
                    FATLength = BitConverter.ToUInt32(sector, 84),
                    ClusterHeapOffset = BitConverter.ToUInt32(sector, 88),
                    ClusterCount = BitConverter.ToUInt32(sector, 92),
                        RootDirectoryCluster = BitConverter.ToUInt32(sector, 96)
                    };

                    bootSector.BytesPerSector = (uint)(1 << bootSector.BytesPerSectorShift);
                bootSector.SectorsPerCluster = (uint)(1 << bootSector.SectorsPerClusterShift);

                return bootSector;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error reading exFAT boot sector: {ex.Message}");
                return null;
                    }
                }

                private FAT16BootSector ReadFAT16BootSector(Stream diskStream)
        {
            try
            {
                byte[] sector = new byte[512];
                diskStream.Position = 0;
                diskStream.Read(sector, 0, 512);

                var bootSector = new FAT16BootSector
                {
                    BytesPerSector = BitConverter.ToUInt16(sector, 11),
                    SectorsPerCluster = sector[13],
                    ReservedSectors = BitConverter.ToUInt16(sector, 14),
                    NumberOfFATs = sector[16],
                    RootEntryCount = BitConverter.ToUInt16(sector, 17),
                    TotalSectors16 = BitConverter.ToUInt16(sector, 19),
                    MediaDescriptor = sector[21],
                    SectorsPerFAT = BitConverter.ToUInt16(sector, 22)
                };

                return bootSector;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error reading FAT16 boot sector: {ex.Message}");
                return null;
                    }
                }

                private void ScanDirectoryCluster(Stream diskStream, FAT32BootSector bootSector, uint cluster, string dirPath, List<FileEntry> deletedFiles, HashSet<uint> visitedClusters)
        {
            try
            {
                if (!IsValidFAT32Cluster(cluster) || visitedClusters.Contains(cluster))
                    return;

                visitedClusters.Add(cluster);

                System.Diagnostics.Debug.WriteLine($"Scanning cluster {cluster} for directory: {dirPath}");

                long clusterOffset = GetClusterOffset(bootSector, cluster);
                long clusterSize = bootSector.BytesPerSector * bootSector.SectorsPerCluster;

                byte[] clusterData = new byte[clusterSize];
                diskStream.Position = clusterOffset;
                int bytesRead = diskStream.Read(clusterData, 0, (int)clusterSize);

                if (bytesRead != clusterSize)
                {
                        System.Diagnostics.Debug.WriteLine($"Warning: Only read {bytesRead} of {clusterSize} bytes");
                    }

                    var subdirectoryClusters = new List<uint>();
                    var subdirectoryNames = new List<string>();
                    ParseDirectoryEntries(clusterData, dirPath, deletedFiles, subdirectoryClusters, subdirectoryNames, false);

                    uint nextCluster = ReadFATEntry(diskStream, bootSector, cluster);
                if (IsValidFAT32Cluster(nextCluster))
                {
                        ScanDirectoryCluster(diskStream, bootSector, nextCluster, dirPath, deletedFiles, visitedClusters);
                    }

                    for (int i = 0; i < subdirectoryClusters.Count; i++)
                {
                    uint subdirCluster = subdirectoryClusters[i];
                    string subdirName = i < subdirectoryNames.Count ? subdirectoryNames[i] : $"subdir_{subdirCluster}";
                    string subdirPath = BuildSubdirectoryPath(dirPath, subdirName);
                    ScanDirectoryCluster(diskStream, bootSector, subdirCluster, subdirPath, deletedFiles, visitedClusters);
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error scanning cluster {cluster}: {ex.Message}");
                    }
                }

                private void ParseDirectoryEntries(byte[] clusterData, string dirPath, List<FileEntry> deletedFiles,
            List<uint> subdirectoryClusters, List<string> subdirectoryNames, bool isFAT16)
        {
            List<byte[]> lfnEntries = new List<byte[]>();

            for (int offset = 0; offset < clusterData.Length; offset += DIRECTORY_ENTRY_SIZE)
            {
                byte[] entryBuffer = new byte[DIRECTORY_ENTRY_SIZE];
                Array.Copy(clusterData, offset, entryBuffer, 0, DIRECTORY_ENTRY_SIZE);

                byte firstByte = entryBuffer[0];

                if (firstByte == DIRECTORY_END_MARKER)
                    break;

                if (firstByte == 0x20)
                    continue;

                byte attributes = entryBuffer[11];
                bool isLFN = (attributes == LFN_ATTRIBUTE);
                bool isDeleted = (firstByte == DELETED_MARKER);
                bool isVolumeLabel = (attributes & VOLUME_LABEL_ATTRIBUTE) != 0;

                if (isLFN)
                {
                    byte[] lfnCopy = new byte[DIRECTORY_ENTRY_SIZE];
                    Array.Copy(entryBuffer, lfnCopy, DIRECTORY_ENTRY_SIZE);
                    lfnEntries.Add(lfnCopy);
                }
                else if (!isVolumeLabel && firstByte != 0x2E)
                {
                    var entry = ParseSingleEntry(entryBuffer, isDeleted, lfnEntries);

                    if (entry != null)
                    {
                        if (entry.IsDeleted)
                        {
                            string fileName = entry.LongName ?? entry.ShortName ?? "[Unknown]";
                            var fileEntry = CreateFileEntry(entry, dirPath, fileName);
                            deletedFiles.Add(fileEntry);
                            string fsType = isFAT16 ? "FAT16" : "FAT32";
                                System.Diagnostics.Debug.WriteLine($"Found deleted {fsType} file: {fileEntry.ReconstructedFileName} ({fileEntry.FileSizeFormatted})");
                            }

                            bool isValidCluster = isFAT16 ? IsValidFAT16Cluster(entry.FirstCluster) : IsValidFAT32Cluster(entry.FirstCluster);
                        if (!entry.IsDeleted && entry.IsDirectory && isValidCluster)
                        {
                            subdirectoryClusters.Add(entry.FirstCluster);
                            subdirectoryNames.Add(entry.LongName ?? entry.ShortName);
                        }
                    }

                    lfnEntries.Clear();
                }
                    }
                }

                private void ScanFAT16RootDirectory(Stream diskStream, FAT16BootSector bootSector, string rootPath, List<FileEntry> deletedFiles)
                    {
                        try
                        {
                            System.Diagnostics.Debug.WriteLine($"Scanning FAT16 root directory: {rootPath}");

                            long rootDirOffset = (bootSector.ReservedSectors + (bootSector.NumberOfFATs * bootSector.SectorsPerFAT)) * bootSector.BytesPerSector;
                            long rootDirSize = bootSector.RootEntryCount * 32;

                            byte[] rootDirData = new byte[rootDirSize];
                            diskStream.Position = rootDirOffset;
                            int bytesRead = diskStream.Read(rootDirData, 0, (int)rootDirSize);

                            if (bytesRead != rootDirSize)
                            {
                                    System.Diagnostics.Debug.WriteLine($"Warning: Only read {bytesRead} of {rootDirSize} bytes from root directory");
                                }

                                var subdirectoryClusters = new List<uint>();
                                var subdirectoryNames = new List<string>();
                                ParseDirectoryEntries(rootDirData, rootPath, deletedFiles, subdirectoryClusters, subdirectoryNames, true);

                                for (int i = 0; i < subdirectoryClusters.Count; i++)
                            {
                                uint subdirCluster = subdirectoryClusters[i];
                                string subdirName = i < subdirectoryNames.Count ? subdirectoryNames[i] : $"subdir_{subdirCluster}";
                                string subdirPath = BuildSubdirectoryPath(rootPath, subdirName);
                                ScanFAT16DirectoryCluster(diskStream, bootSector, subdirCluster, subdirPath, deletedFiles, new HashSet<uint>());
                            }
                        }
                        catch (Exception ex)
                        {
                            System.Diagnostics.Debug.WriteLine($"Error scanning FAT16 root directory: {ex.Message}");
                                                }
                                            }

                                    private void ScanFAT16DirectoryCluster(Stream diskStream, FAT16BootSector bootSector, uint cluster, string dirPath, List<FileEntry> deletedFiles, HashSet<uint> visitedClusters)
                {
                    try
                    {
                        if (!IsValidFAT16Cluster(cluster) || visitedClusters.Contains(cluster))
                            return;

                        visitedClusters.Add(cluster);

                        System.Diagnostics.Debug.WriteLine($"Scanning FAT16 cluster {cluster} for directory: {dirPath}");

                        long clusterOffset = GetFAT16ClusterOffset(bootSector, cluster);
                        long clusterSize = bootSector.BytesPerSector * bootSector.SectorsPerCluster;

                        byte[] clusterData = new byte[clusterSize];
                        diskStream.Position = clusterOffset;
                        int bytesRead = diskStream.Read(clusterData, 0, (int)clusterSize);

                        if (bytesRead != clusterSize)
                        {
                                System.Diagnostics.Debug.WriteLine($"Warning: Only read {bytesRead} of {clusterSize} bytes");
                            }

                            var subdirectoryClusters = new List<uint>();
                            var subdirectoryNames = new List<string>();
                            ParseDirectoryEntries(clusterData, dirPath, deletedFiles, subdirectoryClusters, subdirectoryNames, true);

                            uint nextCluster = ReadFAT16Entry(diskStream, bootSector, cluster);
                        if (IsValidFAT16Cluster(nextCluster))
                        {
                                ScanFAT16DirectoryCluster(diskStream, bootSector, nextCluster, dirPath, deletedFiles, visitedClusters);
                            }

                            for (int i = 0; i < subdirectoryClusters.Count; i++)
                        {
                            uint subdirCluster = subdirectoryClusters[i];
                            string subdirName = i < subdirectoryNames.Count ? subdirectoryNames[i] : $"subdir_{subdirCluster}";
                            string subdirPath = BuildSubdirectoryPath(dirPath, subdirName);
                            ScanFAT16DirectoryCluster(diskStream, bootSector, subdirCluster, subdirPath, deletedFiles, visitedClusters);
                        }
                    }
                    catch (Exception ex)
                    {
                        System.Diagnostics.Debug.WriteLine($"Error scanning FAT16 cluster {cluster}: {ex.Message}");
                                                }
                                            }

                                        private long GetClusterOffset(FAT32BootSector bootSector, uint cluster)
                            {
                                long firstDataSector = bootSector.ReservedSectors + (bootSector.NumberOfFATs * bootSector.SectorsPerFAT);
                                long clusterSector = firstDataSector + ((cluster - 2) * bootSector.SectorsPerCluster);
                                    return clusterSector * bootSector.BytesPerSector;
                                }

                                private long GetFAT16ClusterOffset(FAT16BootSector bootSector, uint cluster)
                            {
                                long rootDirSectors = (bootSector.RootEntryCount * 32 + bootSector.BytesPerSector - 1) / bootSector.BytesPerSector;
            long firstDataSector = bootSector.ReservedSectors + (bootSector.NumberOfFATs * bootSector.SectorsPerFAT) + rootDirSectors;
            long clusterSector = firstDataSector + ((cluster - 2) * bootSector.SectorsPerCluster);
                    return clusterSector * bootSector.BytesPerSector;
                }

                private uint ReadFATEntry(Stream diskStream, FAT32BootSector bootSector, uint cluster)
        {
            try
            {
                long fatOffset = bootSector.ReservedSectors * bootSector.BytesPerSector;
                long entryOffset = fatOffset + (cluster * 4);

                byte[] entryBytes = new byte[4];
                diskStream.Position = entryOffset;
                diskStream.Read(entryBytes, 0, 4);

                uint value = BitConverter.ToUInt32(entryBytes, 0) & 0x0FFFFFFF;
                return value;
            }
            catch
            {
                return 0xFFFFFFFF;
                    }
                }

                private uint ReadFAT16Entry(Stream diskStream, FAT16BootSector bootSector, uint cluster)
        {
            try
            {
                long fatOffset = bootSector.ReservedSectors * bootSector.BytesPerSector;
                long entryOffset = fatOffset + (cluster * 2);

                byte[] entryBytes = new byte[2];
                diskStream.Position = entryOffset;
                diskStream.Read(entryBytes, 0, 2);

                uint value = BitConverter.ToUInt16(entryBytes, 0);
                return value;
            }
            catch
            {
                return 0xFFFF;
                        }
                    }

                    private int CalculateConfidence(RawDirectoryEntry entry)
                {
                    int confidence = 30;
            
            if (entry.LongName != null)
                confidence += 30;
            
            if (entry.CreationTime != null)
                confidence += 20;
                
            if (entry.FileSize > 0 && !entry.IsDirectory)
                confidence += 10;
                
            if (entry.FirstCluster >= 2 && entry.FirstCluster < 0x0FFFFFF8)
                confidence += 10;
            
                    return Math.Min(confidence, 100);
                }

                private string BuildReconstructionNotes(RawDirectoryEntry entry)
        {
            var notes = new List<string>
            {
                "First character of filename replaced with '?'"
            };
            
            if (entry.LongName != null)
                notes.Add("Long filename recovered from LFN entries");
            else
                notes.Add("Only 8.3 short name available");
                
            if (entry.FirstCluster < 2)
                notes.Add("WARNING: Invalid cluster - data may be unrecoverable");
            
                    return string.Join("; ", notes);
                }

                private RawDirectoryEntry ParseSingleEntry(byte[] buffer, bool isDeleted, List<byte[]> lfnEntries)
        {
            try
            {
                var entry = new RawDirectoryEntry
                {
                        IsDeleted = isDeleted
                    };

                    byte[] nameBytes = new byte[8];
                byte[] extBytes = new byte[3];
                Array.Copy(buffer, 0, nameBytes, 0, 8);
                Array.Copy(buffer, 8, extBytes, 0, 3);

                string name = Encoding.ASCII.GetString(nameBytes).TrimEnd();
                string ext = Encoding.ASCII.GetString(extBytes).TrimEnd();

                if (isDeleted && name.Length > 0)
                {
                    name = "?" + name.Substring(1);
                }

                entry.ShortName = string.IsNullOrEmpty(ext) ? name : $"{name}.{ext}";

                entry.Attributes = ((FileAttributes)buffer[11]).ToString();
                entry.IsDirectory = (buffer[11] & 0x10) != 0;

                entry.CreationTime = ParseFatDateTime(buffer, 16, 14);
                entry.AccessTime = ParseFatDate(buffer, 18);
                entry.ModifiedTime = ParseFatDateTime(buffer, 24, 22);

                ushort clusterLow = BitConverter.ToUInt16(buffer, 26);
                ushort clusterHigh = BitConverter.ToUInt16(buffer, 20);
                entry.FirstCluster = ((uint)clusterHigh << 16) | clusterLow;
                entry.FileSize = BitConverter.ToUInt32(buffer, 28);

                if (lfnEntries.Count > 0)
                {
                    string reconstructedLFN = ReconstructLongFileName(lfnEntries, isDeleted);
                    
                    if (reconstructedLFN != null)
                    {
                        if (isDeleted)
                        {
                            byte[] shortNameBuffer = new byte[11];
                            Array.Copy(nameBytes, 0, shortNameBuffer, 0, 8);
                            Array.Copy(extBytes, 0, shortNameBuffer, 8, 3);
                            
                            byte expectedChecksum = CalculateLFNChecksum(shortNameBuffer);
                            byte lfnChecksum = lfnEntries.Count > 0 ? lfnEntries[0][13] : (byte)0;

                            System.Diagnostics.Debug.WriteLine($"LFN Checksum: {lfnChecksum:X2}, Expected: {expectedChecksum:X2}, LFN: {reconstructedLFN}");
                        }

                        if (reconstructedLFN.StartsWith("?"))
                        {
                            entry.LongName = RecoverFirstCharacter(reconstructedLFN, entry.ShortName);
                        }
                        else
                        {
                            entry.LongName = reconstructedLFN;
                        }
                    }
                }

                return entry;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error parsing entry: {ex.Message}");
                return null;
                    }
                }

                private string ReconstructLongFileName(List<byte[]> lfnEntries, bool _)
        {
            try
            {
                lfnEntries.Reverse();
                StringBuilder longName = new StringBuilder();

                foreach (var lfnEntry in lfnEntries)
                {
                    longName.Append(ExtractLFNChars(lfnEntry, 1, 10));
                    longName.Append(ExtractLFNChars(lfnEntry, 14, 25));
                    longName.Append(ExtractLFNChars(lfnEntry, 28, 31));
                }

                return longName.ToString().TrimEnd('\0', '\xFF');
            }
            catch
            {
                return null;
                    }
                }

                private string ExtractLFNChars(byte[] buffer, int start, int end)
        {
            StringBuilder chars = new StringBuilder();

            for (int i = start; i <= end; i += 2)
            {
                if (i + 1 < buffer.Length)
                {
                    char c = BitConverter.ToChar(buffer, i);
                    if (c != 0 && c != 0xFFFF)
                    {
                        chars.Append(c);
                    }
                }
            }

                    return chars.ToString();
                }

                private byte CalculateLFNChecksum(byte[] shortNameBytes)
        {
            byte checksum = 0;
            for (int i = 0; i < 11; i++)
            {
                checksum = (byte)(((checksum & 1) << 7) + (checksum >> 1) + shortNameBytes[i]);
            }
                    return checksum;
                }

                private string RecoverFirstCharacter(string lfnWithPlaceholder, string shortName)
        {
            try
            {
                if (string.IsNullOrEmpty(lfnWithPlaceholder))
                    return lfnWithPlaceholder;

                if (!lfnWithPlaceholder.StartsWith("?"))
                    return lfnWithPlaceholder;

                if (string.IsNullOrEmpty(shortName) || shortName.StartsWith("?"))
                    return lfnWithPlaceholder;

                char firstCharFromShort = shortName[0];

                if (lfnWithPlaceholder.Length > 1)
                {
                    char secondChar = lfnWithPlaceholder[1];

                    if (char.IsLower(secondChar) && char.IsUpper(firstCharFromShort))
                    {
                        firstCharFromShort = char.ToLower(firstCharFromShort);
                    }
                }
                
                return firstCharFromShort + lfnWithPlaceholder.Substring(1);
            }
            catch
            {
                return lfnWithPlaceholder;
                    }
                }

                private DateTime? ParseFatDateTime(byte[] buffer, int dateOffset, int timeOffset)
        {
            try
            {
                ushort date = BitConverter.ToUInt16(buffer, dateOffset);
                ushort time = BitConverter.ToUInt16(buffer, timeOffset);

                if (date == 0 || time == 0xFFFF || date == 0xFFFF)
                    return null;

                int year = 1980 + ((date >> 9) & 0x7F);
                int month = (date >> 5) & 0x0F;
                int day = date & 0x1F;

                int hour = (time >> 11) & 0x1F;
                int minute = (time >> 5) & 0x3F;
                int second = (time & 0x1F) * 2;

                if (month >= 1 && month <= 12 && day >= 1 && day <= 31 && hour <= 23 && minute <= 59 && second <= 59)
                {
                    try
                    {
                        return new DateTime(year, month, day, hour, minute, second);
                    }
                    catch
                    {
                        return null;
                    }
                }
            }
            catch { }

                    return null;
                }

                private DateTime? ParseFatDate(byte[] buffer, int dateOffset)
        {
            try
            {
                ushort date = BitConverter.ToUInt16(buffer, dateOffset);

                if (date == 0 || date == 0xFFFF)
                    return null;

                int year = 1980 + ((date >> 9) & 0x7F);
                int month = (date >> 5) & 0x0F;
                int day = date & 0x1F;

                if (month >= 1 && month <= 12 && day >= 1 && day <= 31)
                {
                    try
                    {
                        return new DateTime(year, month, day);
                    }
                    catch
                    {
                        return null;
                    }
                }
            }
            catch { }

                    return null;
                }

                public void AnalyzeFileSlack(List<FileEntry> files)
        {
            try
            {
                var clusterSize = GetClusterSize(_driveLetter);

                foreach (var file in files)
                {
                    if (file.FileSize > 0 && !file.IsDirectory)
                    {
                        var remainder = file.FileSize % clusterSize;
                        if (remainder > 0)
                        {
                            file.SlackSpace = clusterSize - remainder;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error analyzing file slack: {ex.Message}");
                    }
                }

                private long GetClusterSize(string driveLetter)
        {
            try
            {
                var drive = driveLetter.TrimEnd('\\');

                if (NativeMethods.GetDiskFreeSpace(drive + "\\",
                    out uint sectorsPerCluster,
                    out uint bytesPerSector,
                    out uint numberOfFreeClusters,
                    out uint totalNumberOfClusters))
                {
                    return sectorsPerCluster * bytesPerSector;
                }
            }
            catch { }

                    return DEFAULT_CLUSTER_SIZE;
                }

                private bool IsAdministrator()
        {
            var identity = WindowsIdentity.GetCurrent();
            var principal = new WindowsPrincipal(identity);
                    return principal.IsInRole(WindowsBuiltInRole.Administrator);
                }

                public bool RecoverFile(FileEntry fileEntry, string outputPath)
        {
            if (fileEntry == null || fileEntry.IsDirectory)
            {
                throw new ArgumentException("Cannot recover directories, only files.");
            }

            if (fileEntry.StartCluster < 2)
            {
                throw new InvalidOperationException("Invalid start cluster for file recovery.");
            }

            try
            {
                if (!IsAdministrator())
                {
                    throw new UnauthorizedAccessException("Administrator privileges required for file recovery.");
                }

                string drivePath = $"\\\\.\\{_driveLetter.TrimEnd('\\')}";

                using (var driveStream = new FileStream(drivePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                {
                    byte[] fileData;
                    long clusterSize;

                    if (_isExFAT)
                    {
                        var bootSector = ReadExFATBootSector(driveStream) ?? throw new InvalidOperationException("Failed to read exFAT boot sector.");
                        clusterSize = bootSector.BytesPerSector * bootSector.SectorsPerCluster;

                        fileData = RecoverContiguousFile(driveStream, bootSector, (uint)fileEntry.StartCluster, fileEntry.FileSize);

                        if ((fileData == null || fileData.Length < fileEntry.FileSize / 2) && fileEntry.FileSize > clusterSize * 2)
                        {
                            System.Diagnostics.Debug.WriteLine("Contiguous recovery incomplete, trying FAT chain fallback");
                            fileData = RecoverFileData(
                                driveStream,
                                (uint)fileEntry.StartCluster,
                                fileEntry.FileSize,
                                clusterSize,
                                "exFAT",
                                cluster => ReadExFATEntry(driveStream, bootSector, cluster),
                                cluster => GetExFATClusterOffset(bootSector, cluster),
                                IsValidExFATCluster);
                        }
                    }
                    else if (_isFAT16)
                    {
                        var bootSector = ReadFAT16BootSector(driveStream) ?? throw new InvalidOperationException("Failed to read FAT16 boot sector.");
                        clusterSize = bootSector.BytesPerSector * bootSector.SectorsPerCluster;
                        fileData = RecoverFileData(
                            driveStream,
                            (uint)fileEntry.StartCluster,
                            fileEntry.FileSize,
                            clusterSize,
                            "FAT16",
                            cluster => ReadFAT16Entry(driveStream, bootSector, cluster),
                            cluster => GetFAT16ClusterOffset(bootSector, cluster),
                            IsValidFAT16Cluster);
                    }
                    else
                    {
                        var bootSector = ReadBootSector(driveStream) ?? throw new InvalidOperationException("Failed to read FAT32 boot sector.");
                        clusterSize = bootSector.BytesPerSector * bootSector.SectorsPerCluster;
                        fileData = RecoverFileData(
                            driveStream,
                            (uint)fileEntry.StartCluster,
                            fileEntry.FileSize,
                            clusterSize,
                            "FAT32",
                            cluster => ReadFATEntry(driveStream, bootSector, cluster),
                            cluster => GetClusterOffset(bootSector, cluster),
                            IsValidFAT32Cluster);
                    }

                    if (fileData != null && fileData.Length > 0)
                    {
                        File.WriteAllBytes(outputPath, fileData);
                        return true;
                    }
                }

                return false;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error recovering file: {ex.Message}");
                throw;
                    }
                }

                private byte[] RecoverFileData(
            Stream diskStream,
            uint startCluster,
            long fileSize,
            long clusterSize,
            string fileSystemType,
            Func<uint, uint> readFATEntry,
            Func<uint, long> getClusterOffset,
            Func<uint, bool> isValidCluster)
        {
            var data = new List<byte>();
            int clustersNeeded = (int)((fileSize + clusterSize - 1) / clusterSize);
            long bytesRemaining = fileSize;

            System.Diagnostics.Debug.WriteLine($"{fileSystemType} Recovery: Start cluster={startCluster}, File size={fileSize}, Cluster size={clusterSize}, Clusters needed={clustersNeeded}");

            var clusterChain = BuildClusterChain(startCluster, clustersNeeded, readFATEntry, isValidCluster);

            foreach (uint cluster in clusterChain)
            {
                if (bytesRemaining <= 0)
                    break;

                long clusterOffset = getClusterOffset(cluster);
                long bytesToRead = Math.Min(clusterSize, bytesRemaining);

                byte[] clusterData = new byte[bytesToRead];
                diskStream.Position = clusterOffset;
                int bytesRead = diskStream.Read(clusterData, 0, (int)bytesToRead);

                if (bytesRead > 0)
                {
                    data.AddRange(clusterData.Take(bytesRead));
                    bytesRemaining -= bytesRead;
                    System.Diagnostics.Debug.WriteLine($"Read cluster {cluster:X} at offset {clusterOffset:X}, bytes: {bytesRead}, remaining: {bytesRemaining}");
                }
                else
                {
                    System.Diagnostics.Debug.WriteLine($"Failed to read cluster {cluster:X}");
                }
            }

            System.Diagnostics.Debug.WriteLine($"Recovery complete. Recovered {data.Count} bytes of {fileSize} bytes");
                    return data.ToArray();
                }

                private byte[] RecoverContiguousFile(Stream diskStream, ExFATBootSector bootSector, uint startCluster, long fileSize)
        {
            long clusterSize = bootSector.BytesPerSector * bootSector.SectorsPerCluster;
            int clustersNeeded = (int)((fileSize + clusterSize - 1) / clusterSize);
            var data = new List<byte>();
            long bytesRemaining = fileSize;

            System.Diagnostics.Debug.WriteLine($"exFAT Contiguous Recovery: Start cluster={startCluster}, File size={fileSize}, Cluster size={clusterSize}, Clusters needed={clustersNeeded}");

            for (int i = 0; i < clustersNeeded && bytesRemaining > 0; i++)
            {
                uint cluster = startCluster + (uint)i;
                long clusterOffset = GetExFATClusterOffset(bootSector, cluster);
                long bytesToRead = Math.Min(clusterSize, bytesRemaining);

                byte[] clusterData = new byte[bytesToRead];
                diskStream.Position = clusterOffset;
                int bytesRead = diskStream.Read(clusterData, 0, (int)bytesToRead);

                if (bytesRead > 0)
                {
                    data.AddRange(clusterData.Take(bytesRead));
                    bytesRemaining -= bytesRead;
                    System.Diagnostics.Debug.WriteLine($"Read contiguous cluster {cluster:X} at offset {clusterOffset:X}, bytes: {bytesRead}, remaining: {bytesRemaining}");
                }
                else
                {
                    System.Diagnostics.Debug.WriteLine($"Failed to read contiguous cluster {cluster:X}");
                    break;
                }
            }

            System.Diagnostics.Debug.WriteLine($"Contiguous recovery complete. Recovered {data.Count} bytes of {fileSize} bytes");
                    return data.ToArray();
                }

                private List<uint> BuildClusterChain(uint startCluster, int clustersNeeded, Func<uint, uint> readFATEntry, Func<uint, bool> isValidCluster)
        {
            var clusterChain = new List<uint>();
            var visitedClusters = new HashSet<uint>();
            uint currentCluster = startCluster;

            while (isValidCluster(currentCluster) && clusterChain.Count < clustersNeeded)
            {
                if (visitedClusters.Contains(currentCluster))
                {
                    System.Diagnostics.Debug.WriteLine($"Circular reference detected at cluster {currentCluster:X}");
                    break;
                }

                visitedClusters.Add(currentCluster);
                clusterChain.Add(currentCluster);

                uint nextCluster = readFATEntry(currentCluster);

                if (nextCluster == 0 || nextCluster == 1)
                {
                    System.Diagnostics.Debug.WriteLine($"FAT chain broken at cluster {currentCluster:X} (next={nextCluster:X}). Likely a deleted file.");
                    break;
                }

                    currentCluster = nextCluster;
                }

                if (clusterChain.Count < clustersNeeded)
            {
                System.Diagnostics.Debug.WriteLine($"FAT chain incomplete ({clusterChain.Count} clusters). Using consecutive clusters starting from {startCluster}.");
                clusterChain.Clear();
                for (int i = 0; i < clustersNeeded; i++)
                {
                    clusterChain.Add(startCluster + (uint)i);
                }
            }

                    return clusterChain;
                }

                private string FormatBytes(long bytes)
            {
                string[] sizes = { "B", "KB", "MB", "GB", "TB" };
                double len = bytes;
                int order = 0;
                while (len >= 1024 && order < sizes.Length - 1)
                {
                    order++;
                    len /= 1024;
                }

                if (len >= 1)
                {
                    long wholePart = (long)len;
                    return $"{wholePart} {sizes[order]}";
                }
                else
                {
                    return $"{len:0.##} {sizes[order]}";
                }
            }

                private FileEntry CreateFileEntry(RawDirectoryEntry entry, string dirPath, string fileName)
            {
                return new FileEntry
                {
                    FileName = entry.ShortName,
                    ReconstructedFileName = entry.LongName ?? entry.ShortName,
                    FullPath = BuildFullFilePath(dirPath, fileName),
                    FileSize = entry.FileSize,
                    FileSizeFormatted = FormatBytes(entry.FileSize),
                    Status = "Deleted",
                    CreationTime = entry.CreationTime,
                    ModifiedTime = entry.ModifiedTime,
                    AccessedTime = entry.AccessTime,
                    Attributes = entry.Attributes,
                    IsDeleted = true,
                    IsDirectory = entry.IsDirectory,
                    StartCluster = entry.FirstCluster,
                    ReconstructionConfidence = CalculateConfidence(entry),
                    ReconstructionSource = entry.LongName != null ? "LFN Entry" : "Short Name",
                    ReconstructionNotes = BuildReconstructionNotes(entry)
                                };
                            }

                        private void ScanExFATDirectoryCluster(Stream diskStream, ExFATBootSector bootSector, uint cluster, string dirPath, List<FileEntry> deletedFiles, HashSet<uint> visitedClusters)
            {
                try
                {
                    if (!IsValidExFATCluster(cluster) || visitedClusters.Contains(cluster))
                        return;

                    visitedClusters.Add(cluster);

                    System.Diagnostics.Debug.WriteLine($"Scanning exFAT cluster {cluster} for directory: {dirPath}");

                    long clusterOffset = GetExFATClusterOffset(bootSector, cluster);
                    long clusterSize = bootSector.BytesPerSector * bootSector.SectorsPerCluster;

                    byte[] clusterData = new byte[clusterSize];
                    diskStream.Position = clusterOffset;
                    int bytesRead = diskStream.Read(clusterData, 0, (int)clusterSize);

                    if (bytesRead != clusterSize)
                    {
                        System.Diagnostics.Debug.WriteLine($"Warning: Only read {bytesRead} of {clusterSize} bytes");
                    }

                    List<uint> subdirectoryClusters = new List<uint>();
                    List<string> subdirectoryNames = new List<string>();

                    for (int offset = 0; offset < clusterData.Length; offset += DIRECTORY_ENTRY_SIZE)
                    {
                        byte[] entryBuffer = new byte[DIRECTORY_ENTRY_SIZE];
                        Array.Copy(clusterData, offset, entryBuffer, 0, DIRECTORY_ENTRY_SIZE);

                        byte entryType = entryBuffer[0];

                        if (entryType == DIRECTORY_END_MARKER)
                            break;

                        bool isInUse = (entryType & 0x80) != 0;
                        bool isDeleted = !isInUse;

                        byte actualType = (byte)(entryType & 0x7F);

                        if (actualType == 0x05)
                        {
                            var fileEntry = ParseExFATFileEntry(clusterData, offset, isDeleted, dirPath);
                            if (fileEntry != null)
                            {
                                if (fileEntry.IsDeleted)
                                {
                                    deletedFiles.Add(fileEntry);
                                    System.Diagnostics.Debug.WriteLine($"Found deleted exFAT file: {fileEntry.ReconstructedFileName} ({fileEntry.FileSizeFormatted})");
                                }

                                if (!fileEntry.IsDeleted && fileEntry.IsDirectory && IsValidExFATCluster((uint)fileEntry.StartCluster))
                                {
                                    subdirectoryClusters.Add((uint)fileEntry.StartCluster);
                                    subdirectoryNames.Add(fileEntry.ReconstructedFileName);
                                }
                            }
                        }
                    }

                    uint nextCluster = ReadExFATEntry(diskStream, bootSector, cluster);
                    if (IsValidExFATCluster(nextCluster))
                    {
                        ScanExFATDirectoryCluster(diskStream, bootSector, nextCluster, dirPath, deletedFiles, visitedClusters);
                    }

                    for (int i = 0; i < subdirectoryClusters.Count; i++)
                    {
                        uint subdirCluster = subdirectoryClusters[i];
                        string subdirName = i < subdirectoryNames.Count ? subdirectoryNames[i] : $"subdir_{subdirCluster}";
                        string subdirPath = BuildSubdirectoryPath(dirPath, subdirName);
                        ScanExFATDirectoryCluster(diskStream, bootSector, subdirCluster, subdirPath, deletedFiles, visitedClusters);
                    }
                }
                catch (Exception ex)
                {
                    System.Diagnostics.Debug.WriteLine($"Error scanning exFAT cluster {cluster}: {ex.Message}");
                                }
                            }

                        private FileEntry ParseExFATFileEntry(byte[] clusterData, int fileEntryOffset, bool isDeleted, string dirPath)
            {
                try
                {
                    byte[] fileEntry = new byte[DIRECTORY_ENTRY_SIZE];
                    Array.Copy(clusterData, fileEntryOffset, fileEntry, 0, DIRECTORY_ENTRY_SIZE);

                    byte secondaryCount = fileEntry[1];

                    if (secondaryCount < 2)
                    {
                        return null;
                    }

                    int streamOffset = fileEntryOffset + DIRECTORY_ENTRY_SIZE;
                    if (streamOffset + DIRECTORY_ENTRY_SIZE > clusterData.Length)
                        return null;

                    byte[] streamEntry = new byte[DIRECTORY_ENTRY_SIZE];
                    Array.Copy(clusterData, streamOffset, streamEntry, 0, DIRECTORY_ENTRY_SIZE);

                    byte streamType = (byte)(streamEntry[0] & 0x7F);
                    if (streamType != 0x40)
                            return null;

                        byte generalSecondaryFlags = streamEntry[1];
                        bool noFatChain = (generalSecondaryFlags & 0x02) != 0;

                    ushort fileAttributes = BitConverter.ToUInt16(fileEntry, 4);
                    bool isDirectory = (fileAttributes & 0x0010) != 0;

                    ulong fileSize = BitConverter.ToUInt64(streamEntry, 8);
                    uint firstCluster = BitConverter.ToUInt32(streamEntry, 20);
                    ulong dataLength = BitConverter.ToUInt64(streamEntry, 16);

                    DateTime? creationTime = ParseExFATDateTime(fileEntry, 8);
                    DateTime? modifiedTime = ParseExFATDateTime(fileEntry, 12);
                    DateTime? accessedTime = ParseExFATDateTime(fileEntry, 16);

                    byte nameLength = streamEntry[3];

                    StringBuilder fileName = new StringBuilder();
                    int filenameEntryCount = secondaryCount - 1;

                    for (int i = 0; i < filenameEntryCount && i < 17; i++)
                    {
                        int filenameOffset = streamOffset + DIRECTORY_ENTRY_SIZE + (i * DIRECTORY_ENTRY_SIZE);
                        if (filenameOffset + DIRECTORY_ENTRY_SIZE > clusterData.Length)
                            break;

                        byte[] filenameEntry = new byte[DIRECTORY_ENTRY_SIZE];
                        Array.Copy(clusterData, filenameOffset, filenameEntry, 0, DIRECTORY_ENTRY_SIZE);

                        byte filenameType = (byte)(filenameEntry[0] & 0x7F);
                        if (filenameType != 0x41)
                                break;

                            for (int j = 2; j < 32 && fileName.Length < nameLength; j += 2)
                        {
                            char c = BitConverter.ToChar(filenameEntry, j);
                            if (c != 0 && c != 0xFFFF)
                            {
                                fileName.Append(c);
                            }
                        }
                    }

                    string finalName = fileName.ToString().TrimEnd('\0');
                    if (string.IsNullOrEmpty(finalName))
                    {
                        finalName = isDirectory ? "[Deleted Directory]" : "[Deleted File]";
                    }

                    string fullPath = BuildFullFilePath(dirPath, finalName);

                    var entry = new FileEntry
                    {
                        FileName = finalName,
                        ReconstructedFileName = finalName,
                        FullPath = fullPath,
                        FileSize = (long)fileSize,
                        FileSizeFormatted = FormatBytes((long)fileSize),
                        Status = isDeleted ? "Deleted" : "Present",
                        CreationTime = creationTime,
                        ModifiedTime = modifiedTime,
                        AccessedTime = accessedTime,
                        Attributes = ConvertExFATAttributes(fileAttributes),
                        IsDeleted = isDeleted,
                        IsDirectory = isDirectory,
                        StartCluster = firstCluster,
                        UseContiguousClusters = noFatChain,
                        ReconstructionConfidence = CalculateExFATConfidence(finalName, fileSize, creationTime),
                        ReconstructionSource = "exFAT Directory Entry",
                        ReconstructionNotes = isDeleted ? "Recovered from exFAT deleted entry" : "Active exFAT entry"
                    };

                    return entry;
                }
                catch (Exception ex)
                {
                    System.Diagnostics.Debug.WriteLine($"Error parsing exFAT file entry: {ex.Message}");
                    return null;
                                }
                            }

                        private DateTime? ParseExFATDateTime(byte[] buffer, int offset)
            {
                try
                {
                    uint timestamp = BitConverter.ToUInt32(buffer, offset);

                    if (timestamp == 0 || timestamp == 0xFFFFFFFF)
                        return null;

                    int year = 1980 + (int)((timestamp >> 25) & 0x7F);
                    int month = (int)((timestamp >> 21) & 0x0F);
                    int day = (int)((timestamp >> 16) & 0x1F);
                    int hour = (int)((timestamp >> 11) & 0x1F);
                    int minute = (int)((timestamp >> 5) & 0x3F);
                    int second = (int)((timestamp & 0x1F) * 2);

                    if (month >= 1 && month <= 12 && day >= 1 && day <= 31 && hour <= 23 && minute <= 59 && second <= 59)
                    {
                        try
                        {
                            return new DateTime(year, month, day, hour, minute, second);
                        }
                        catch
                        {
                            return null;
                        }
                    }
                }
                catch { }

                                return null;
                            }

                        private string ConvertExFATAttributes(ushort attributes)
            {
                var attrList = new List<string>();

                if ((attributes & 0x0001) != 0) attrList.Add("ReadOnly");
                if ((attributes & 0x0002) != 0) attrList.Add("Hidden");
                if ((attributes & 0x0004) != 0) attrList.Add("System");
                if ((attributes & 0x0010) != 0) attrList.Add("Directory");
                if ((attributes & 0x0020) != 0) attrList.Add("Archive");

                                    return attrList.Count > 0 ? string.Join(", ", attrList) : "Normal";
                                }

                            private int CalculateExFATConfidence(string fileName, ulong fileSize, DateTime? creationTime)
                        {
                            int confidence = 50;

                if (!string.IsNullOrEmpty(fileName) && !fileName.StartsWith("["))
                    confidence += 30;

                if (creationTime != null)
                    confidence += 10;

                if (fileSize > 0)
                    confidence += 10;

                                    return Math.Min(confidence, 100);
                                }

                            private long GetExFATClusterOffset(ExFATBootSector bootSector, uint cluster)
                        {
                            long clusterHeapOffset = bootSector.ClusterHeapOffset * bootSector.BytesPerSector;
                            long clusterSize = bootSector.BytesPerSector * bootSector.SectorsPerCluster;
                                    return clusterHeapOffset + ((cluster - 2) * clusterSize);
                                }

                            private uint ReadExFATEntry(Stream diskStream, ExFATBootSector bootSector, uint cluster)
            {
                try
                {
                    long fatOffset = bootSector.FATOffset * bootSector.BytesPerSector;
                    long entryOffset = fatOffset + (cluster * 4);

                    byte[] entryBytes = new byte[4];
                    diskStream.Position = entryOffset;
                    diskStream.Read(entryBytes, 0, 4);

                    uint value = BitConverter.ToUInt32(entryBytes, 0);
                    return value;
                }
                catch
                {
                    return 0xFFFFFFFF;
                                        }
                                    }
                                }

                            internal class FAT32BootSector
                            {
                                public ushort BytesPerSector { get; set; }
                                public byte SectorsPerCluster { get; set; }
                                public ushort ReservedSectors { get; set; }
                                public byte NumberOfFATs { get; set; }
                                public uint SectorsPerFAT { get; set; }
                                public uint RootCluster { get; set; }
                            }

                internal class FAT16BootSector
                {
                    public ushort BytesPerSector { get; set; }
                    public byte SectorsPerCluster { get; set; }
                    public ushort ReservedSectors { get; set; }
                    public byte NumberOfFATs { get; set; }
                    public ushort RootEntryCount { get; set; }
                    public ushort TotalSectors16 { get; set; }
                    public byte MediaDescriptor { get; set; }
                    public ushort SectorsPerFAT { get; set; }
                }

                internal class ExFATBootSector
                {
                    public byte BytesPerSectorShift { get; set; }
                    public byte SectorsPerClusterShift { get; set; }
                    public uint BytesPerSector { get; set; }
                    public uint SectorsPerCluster { get; set; }
                    public byte NumberOfFATs { get; set; }
                    public ulong PartitionOffset { get; set; }
                    public ulong VolumeLength { get; set; }
                    public uint FATOffset { get; set; }
                    public uint FATLength { get; set; }
                    public uint ClusterHeapOffset { get; set; }
                    public uint ClusterCount { get; set; }
                    public uint RootDirectoryCluster { get; set; }
                }

        internal class RawDirectoryEntry
        {
            public string ShortName { get; set; }
            public string LongName { get; set; }
            public bool IsDeleted { get; set; }
            public bool IsDirectory { get; set; }
            public string Attributes { get; set; }
            public DateTime? CreationTime { get; set; }
            public DateTime? ModifiedTime { get; set; }
            public DateTime? AccessTime { get; set; }
            public uint FirstCluster { get; set; }
            public uint FileSize { get; set; }
        }

        internal static class NativeMethods
        {
            [System.Runtime.InteropServices.DllImport("kernel32.dll", SetLastError = true, CharSet = System.Runtime.InteropServices.CharSet.Auto)]
            [return: System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.Bool)]
            internal static extern bool GetDiskFreeSpace(
            string lpRootPathName,
            out uint lpSectorsPerCluster,
            out uint lpBytesPerSector,
            out uint lpNumberOfFreeClusters,
            out uint lpTotalNumberOfClusters);
    }
}
